'use strict';

// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.dispatchEvent = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("../utils");
const flatten_js_1 = tslib_1.__importDefault(require("lodash/flatten.js"));
const core_1 = require("@aws-amplify/core");
const eventListeners_1 = require("../../../../eventListeners");
const errors_1 = require("../../../errors");
const setConflictHandler_1 = require("./setConflictHandler");
const utils_2 = require("../../../utils");
/**
 * Triggers an In-App message to be displayed. Use this after your campaigns have been synced to the device using
 * {@link syncMessages}. Based on the messages synced and the event passed to this API, it triggers the display
 * of the In-App message that meets the criteria.
 *
 * @remark
 * If an event would trigger multiple messages, the message closest to expiry will be chosen by default.
 * To change this behavior, you can use the {@link setConflictHandler} API to provide
 * your own logic for resolving message conflicts.
 *
 * @param DispatchEventInput The input object that holds the event to be dispatched.
 * @throws validation: {@link InAppMessagingValidationErrorCode} - Thrown when the provided parameters or library
 * configuration is incorrect, or if In App messaging hasn't been initialized.
 * @throws service exceptions - Thrown when the underlying Pinpoint service returns an error.
 * @returns A promise that will resolve when the operation is complete.
 * @example
 * ```ts
 * // Sync message before disptaching an event
 * await syncMessages();
 *
 * // Dispatch an event
 * await dispatchEvent({ name: 'test_event' });
 * ```
 */
async function dispatchEvent(input) {
    (0, utils_2.assertIsInitialized)();
    try {
        const key = `${utils_1.PINPOINT_KEY_PREFIX}${utils_1.STORAGE_KEY_SUFFIX}`;
        const cachedMessages = await core_1.defaultStorage.getItem(key);
        const messages = await (0, utils_1.processInAppMessages)(cachedMessages ? JSON.parse(cachedMessages) : [], input);
        const flattenedMessages = (0, flatten_js_1.default)(messages);
        if (flattenedMessages.length > 0) {
            (0, eventListeners_1.notifyEventListeners)('messageReceived', (0, setConflictHandler_1.conflictHandler)(flattenedMessages));
        }
    }
    catch (error) {
        (0, errors_1.assertServiceError)(error);
        throw error;
    }
}
exports.dispatchEvent = dispatchEvent;
//# sourceMappingURL=dispatchEvent.js.map
