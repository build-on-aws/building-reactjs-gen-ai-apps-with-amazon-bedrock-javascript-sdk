{"version":3,"file":"setConflictHandler.js","sources":["../../../../../../src/inAppMessaging/providers/pinpoint/apis/setConflictHandler.ts"],"sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setConflictHandler = exports.conflictHandler = void 0;\nconst utils_1 = require(\"../../../utils\");\nexports.conflictHandler = defaultConflictHandler;\n/**\n * Set a conflict handler that will be used to resolve conflicts that may emerge\n * when matching events with synced messages.\n *\n * @remark\n * The conflict handler is not persisted across app restarts and so must be set again before dispatching an event for\n * any custom handling to take effect.\n * @throws validation: {@link InAppMessagingValidationErrorCode} - Thrown when the provided parameters or library\n * configuration is incorrect, or if In App messaging hasn't been initialized.\n * @param SetConflictHandlerInput: The input object that holds the conflict handler to be used.\n * @example\n * ```ts\n * // Sync messages before dispatching an event\n * await syncMessages();\n *\n * // Example custom conflict handler\n * const myConflictHandler = (messages) => {\n * \t\t// Return a random message\n * \t\tconst randomIndex = Math.floor(Math.random() * messages.length);\n * \t\treturn messages[randomIndex];\n *  };\n *\n * // Set the conflict handler\n * setConflictHandler(myConflictHandler);\n *\n * // Dispatch an event\n * await dispatchEvent({ name: 'test_event' });\n * ```\n */\nfunction setConflictHandler(input) {\n    (0, utils_1.assertIsInitialized)();\n    exports.conflictHandler = input;\n}\nexports.setConflictHandler = setConflictHandler;\nfunction defaultConflictHandler(messages) {\n    // default behavior is to return the message closest to expiry\n    // this function assumes that messages processed by providers already filters out expired messages\n    const sorted = messages.sort((a, b) => {\n        const endDateA = a.metadata?.endDate;\n        const endDateB = b.metadata?.endDate;\n        // if both message end dates are falsy or have the same date string, treat them as equal\n        if (endDateA === endDateB) {\n            return 0;\n        }\n        // if only message A has an end date, treat it as closer to expiry\n        if (endDateA && !endDateB) {\n            return -1;\n        }\n        // if only message B has an end date, treat it as closer to expiry\n        if (!endDateA && endDateB) {\n            return 1;\n        }\n        // otherwise, compare them\n        return new Date(endDateA) < new Date(endDateB) ? -1 : 1;\n    });\n    // always return the top sorted\n    return sorted[0];\n}\n"],"names":[],"mappings":";;AACA;AACA;AACA,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,YAAY,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;AAC9D,OAAO,CAAC,kBAAkB,GAAG,OAAO,CAAC,eAAe,GAAG,KAAK,CAAC,CAAC;AAC9D,MAAM,OAAO,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC;AAC1C,OAAO,CAAC,eAAe,GAAG,sBAAsB,CAAC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kBAAkB,CAAC,KAAK,EAAE;AACnC,IAAI,IAAI,OAAO,CAAC,mBAAmB,GAAG,CAAC;AACvC,IAAI,OAAO,CAAC,eAAe,GAAG,KAAK,CAAC;AACpC,CAAC;AACD,OAAO,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;AAChD,SAAS,sBAAsB,CAAC,QAAQ,EAAE;AAC1C;AACA;AACA,IAAI,MAAM,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK;AAC3C,QAAQ,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,OAAO,CAAC;AAC7C,QAAQ,MAAM,QAAQ,GAAG,CAAC,CAAC,QAAQ,EAAE,OAAO,CAAC;AAC7C;AACA,QAAQ,IAAI,QAAQ,KAAK,QAAQ,EAAE;AACnC,YAAY,OAAO,CAAC,CAAC;AACrB,SAAS;AACT;AACA,QAAQ,IAAI,QAAQ,IAAI,CAAC,QAAQ,EAAE;AACnC,YAAY,OAAO,CAAC,CAAC,CAAC;AACtB,SAAS;AACT;AACA,QAAQ,IAAI,CAAC,QAAQ,IAAI,QAAQ,EAAE;AACnC,YAAY,OAAO,CAAC,CAAC;AACrB,SAAS;AACT;AACA,QAAQ,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;AAChE,KAAK,CAAC,CAAC;AACP;AACA,IAAI,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;AACrB;;"}