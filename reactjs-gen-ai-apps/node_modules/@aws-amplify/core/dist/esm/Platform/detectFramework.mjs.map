{"version":3,"file":"detectFramework.mjs","sources":["../../../src/Platform/detectFramework.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Framework } from './types';\nimport { detect } from './detection';\n// We want to cache detection since the framework won't change\nlet frameworkCache;\nexport const frameworkChangeObservers = [];\n// Setup the detection reset tracking / timeout delays\nlet resetTriggered = false;\nconst SSR_RESET_TIMEOUT = 10; // ms\nconst WEB_RESET_TIMEOUT = 10; // ms\nconst PRIME_FRAMEWORK_DELAY = 1000; // ms\nexport const detectFramework = () => {\n    if (!frameworkCache) {\n        frameworkCache = detect();\n        if (resetTriggered) {\n            // The final run of detectFramework:\n            // Starting from this point, the `frameworkCache` becomes \"final\".\n            // So we don't need to notify the observers again so the observer\n            // can be removed after the final notice.\n            while (frameworkChangeObservers.length) {\n                frameworkChangeObservers.pop()?.();\n            }\n        }\n        else {\n            // The first run of detectFramework:\n            // Every time we update the cache, call each observer function\n            frameworkChangeObservers.forEach(fcn => fcn());\n        }\n        // Retry once for either Unknown type after a delay (explained below)\n        resetTimeout(Framework.ServerSideUnknown, SSR_RESET_TIMEOUT);\n        resetTimeout(Framework.WebUnknown, WEB_RESET_TIMEOUT);\n    }\n    return frameworkCache;\n};\n/**\n * @internal Setup observer callback that will be called everytime the framework changes\n */\nexport const observeFrameworkChanges = (fcn) => {\n    // When the `frameworkCache` won't be updated again, we ignore all incoming\n    // observers.\n    if (resetTriggered) {\n        return;\n    }\n    frameworkChangeObservers.push(fcn);\n};\nexport function clearCache() {\n    frameworkCache = undefined;\n}\n// For a framework type and a delay amount, setup the event to re-detect\n//   During the runtime boot, it is possible that framework detection will\n//   be triggered before the framework has made modifications to the\n//   global/window/etc needed for detection. When no framework is detected\n//   we will reset and try again to ensure we don't use a cached\n//   non-framework detection result for all requests.\nfunction resetTimeout(framework, delay) {\n    if (frameworkCache === framework && !resetTriggered) {\n        setTimeout(() => {\n            clearCache();\n            resetTriggered = true;\n            setTimeout(detectFramework, PRIME_FRAMEWORK_DELAY);\n        }, delay);\n    }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AAGA;AACA,IAAI,cAAc,CAAC;AACP,MAAC,wBAAwB,GAAG,GAAG;AAC3C;AACA,IAAI,cAAc,GAAG,KAAK,CAAC;AAC3B,MAAM,iBAAiB,GAAG,EAAE,CAAC;AAC7B,MAAM,iBAAiB,GAAG,EAAE,CAAC;AAC7B,MAAM,qBAAqB,GAAG,IAAI,CAAC;AACvB,MAAC,eAAe,GAAG,MAAM;AACrC,IAAI,IAAI,CAAC,cAAc,EAAE;AACzB,QAAQ,cAAc,GAAG,MAAM,EAAE,CAAC;AAClC,QAAQ,IAAI,cAAc,EAAE;AAC5B;AACA;AACA;AACA;AACA,YAAY,OAAO,wBAAwB,CAAC,MAAM,EAAE;AACpD,gBAAgB,wBAAwB,CAAC,GAAG,EAAE,IAAI,CAAC;AACnD,aAAa;AACb,SAAS;AACT,aAAa;AACb;AACA;AACA,YAAY,wBAAwB,CAAC,OAAO,CAAC,GAAG,IAAI,GAAG,EAAE,CAAC,CAAC;AAC3D,SAAS;AACT;AACA,QAAQ,YAAY,CAAC,SAAS,CAAC,iBAAiB,EAAE,iBAAiB,CAAC,CAAC;AACrE,QAAQ,YAAY,CAAC,SAAS,CAAC,UAAU,EAAE,iBAAiB,CAAC,CAAC;AAC9D,KAAK;AACL,IAAI,OAAO,cAAc,CAAC;AAC1B,EAAE;AACF;AACA;AACA;AACY,MAAC,uBAAuB,GAAG,CAAC,GAAG,KAAK;AAChD;AACA;AACA,IAAI,IAAI,cAAc,EAAE;AACxB,QAAQ,OAAO;AACf,KAAK;AACL,IAAI,wBAAwB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACvC,EAAE;AACK,SAAS,UAAU,GAAG;AAC7B,IAAI,cAAc,GAAG,SAAS,CAAC;AAC/B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,YAAY,CAAC,SAAS,EAAE,KAAK,EAAE;AACxC,IAAI,IAAI,cAAc,KAAK,SAAS,IAAI,CAAC,cAAc,EAAE;AACzD,QAAQ,UAAU,CAAC,MAAM;AACzB,YAAY,UAAU,EAAE,CAAC;AACzB,YAAY,cAAc,GAAG,IAAI,CAAC;AAClC,YAAY,UAAU,CAAC,eAAe,EAAE,qBAAqB,CAAC,CAAC;AAC/D,SAAS,EAAE,KAAK,CAAC,CAAC;AAClB,KAAK;AACL;;;;"}